#!/usr/bin/env python3

import json
import os
from collections import defaultdict
import argparse
import csv
import math

server_url = os.getenv("GITHUB_SERVER_URL", "https://github.com")
repo = os.getenv("GITHUB_REPOSITORY", "")
sha = os.getenv("GITHUB_SHA", "")
workspace = os.getenv("GITHUB_WORKSPACE", "")

# increase these values as needed
_min_branch_coverage = 80
_min_line_coverage = 80

_min_complexity = 15

argp = argparse.ArgumentParser(
    description="A tool to generate a report using complexity, coverage, and sarif data"
)
argp.add_argument(
    "-x", "--complexity", help="Location of compltexity report generated by Lizard"
)
argp.add_argument("-c", "--coverage", help="Location of Coverage CSV file")
argp.add_argument("-s", "--sarif", help="Location of SARIF file")
argp.add_argument("-o", "--output", help="Output report file to print to.")
argp.add_argument("-oc", "--output_csv", help="Output report csv file to print to.")
argr = argp.parse_args()

# Load complexity data (function-level from Lizard JSON)
with open(argr.complexity, "r") as f:
    complexity_data = json.load(f)

coverage_data = []
with open(argr.coverage, "r") as f:
    coverage_data = json.load(f)

# Load Semgrep SARIF results
with open(argr.sarif) as f:
    semgrep = json.load(f)

fw = open(argr.output, "w")


def print_report(msg, fw):
    print(f"REPORT: {msg}")
    fw.write(msg + "\n")


_max_level = 4
_level_d = {"info": 1, "warning": 2, "error": 3, "unknown": _max_level}

critical_findings = defaultdict(list)
for result in semgrep["runs"][0]["results"]:
    location = result["locations"][0]["physicalLocation"]
    file_path = location["artifactLocation"]["uri"]
    if "file://" in file_path:
        file_path = file_path.replace("file://","")
        file_path = file_path.replace(workspace + "/", "")
    rule = result["ruleId"]
    level = result.get("level", "warning")
    line_num = location.get("region", {}).get("startLine", 1)

    level_num = _level_d.get(level, _max_level)

    critical_findings[file_path].append(
        {"rule": rule, "line": line_num, "level": level_num}
    )

#print(repr(critical_findings))

print_report("# Developer Pain Point Report\n", fw)

high_risk_functions = []
security_risk_functions = []
all_functions = []
min_ccn = None
max_ccn = None


def get_func_coverage(coverage_data, filename, func_name, start_line, end_line):
    branch_count = 0
    line_count = 0
    line_hit = 0
    branch_hit = 0

    func_d_a = []
    for file_d in coverage_data:
        filename_cmp = file_d["filename"]
        filename_cmp = filename_cmp.replace(workspace + "/", "")

        if filename == filename_cmp:
            func_coverage_d = file_d["function_coverage"]
            for func_d in func_coverage_d:
                line_start = func_d["line_start"]
                line_end = func_d["line_end"]

                if line_start >= start_line and line_end <= end_line:
                    func_d_a.append(func_d)

    if not func_d_a:
        print(
            f"WARN: Could not find {func_name} starting at {start_line}:{end_line} in {filename} in coverage data!"
        )
    for func_d in func_d_a:
        line_count += func_d["line_count"]
        line_hit += func_d["line_hit"]
        branch_count += func_d["branch_count"]
        branch_hit += func_d["branch_hit"]
    output_t = (line_hit, line_count, branch_hit, branch_count)
    print(f"{func_name}:{output_t}")
    return output_t


# Analyze each function
for file_data in complexity_data:
    filename = file_data["filename"]

    for func in file_data.get("function_list", []):
        func_name = func["name"]
        ccn = func["cyclomatic_complexity"]
        start_line = func["start_line"]
        end_line = func["end_line"]

        # update minimum, maximum values
        if not all_functions:
            min_ccn = ccn
            max_ccn = ccn
        if ccn < min_ccn:
            min_ccn = ccn
        if ccn > max_ccn:
            max_ccn = ccn

        # Estimate function-level coverage
        coverage_t = get_func_coverage(
            coverage_data, filename, func_name, start_line, end_line
        )
        lh, lc, bh, bc = coverage_t
        line_coverage = 0
        if lc:
            line_coverage = 100.0 * float(lh) / float(lc)
        branch_coverage = 0
        if bc:
            branch_coverage = 100.0 * float(bh) / float(bc)

        # Create permalink to specific function
        permalink = (
            f"{server_url}/{repo}/blob/{sha}/{filename}#L{start_line}-L{end_line}"
        )

        # Check for critical findings in this function's range
        func_findings = []
        for finding in critical_findings.get(filename, []):
            if start_line <= finding["line"] <= end_line:
                func_findings.append(finding)

        all_functions.append(
            {
                "name": func_name,
                "file": filename,
                "permalink": permalink,
                "ccn": ccn,
                "line_count": lc,
                "branch_count": bc,
                "line_coverage": line_coverage,
                "branch_coverage": branch_coverage,
                "findings": func_findings,
                "score_cplx_locov": 0,
                "score_sca_cov": 0,
            }
        )


if all_functions:

    # update all functions with complexity score
    for func in all_functions:
        ccn = func["ccn"]
        ccn_score = int(100.0 * (ccn - min_ccn) / (max_ccn - min_ccn))
        func["ccn_score"] = ccn_score

        # determine complexity/lowcoverage ranking
        # high complexity + low coverage = high score
        bc = func["branch_count"]
        lc = func["line_count"]

        cov = func["branch_coverage"]
        if not bc:
            cov = func["line_coverage"]
        cov = int(cov)
        inv_cov = 100 - cov
        score_cplx_locov = (ccn_score * 100) + inv_cov
        func["score_cplx_locov"] = int(score_cplx_locov)

        # determine findings/withcoverage ranking
        # #findings + high coverage = high score
        # 0 findings: 0 score
        finding_count = len(func["findings"])
        finding_score = 0

        # take each numerical level attached to each finding and
        # add it to a score, powered by the level
        # so level 1 (info) would get 10 pts
        # level 2 would get 100 pts
        # level 3 1000, etc.
        # ideally a method with one very bad finding should outweigh one with a bunch of
        # small info findings
        for finding_d in func["findings"]:
            level = finding_d["level"]
            s = math.pow(10, level)
            finding_score += s

        score_sca_cov = 0
        if finding_count > 0:
            score_sca_cov = (finding_score * 100) + cov
        func["score_sca_cov"] = int(score_sca_cov)
    # end update scoring

    with open(argr.output_csv, "w") as csv_fw:
        csvw = csv.writer(csv_fw)
        header_a = [
            "file",
            "url",
            "func",
            "ccn",
            "ccn_score",
            "lcount",
            "lcov",
            "bcount",
            "bcov",
            "sca_count",
            "score_cplx_locov",
            "score_sca_cov",
        ]
        csvw.writerow(header_a)

        for func in all_functions:
            row = [
                func["file"],
                func["permalink"],
                func["name"],
                func["ccn"],
                func["ccn_score"],
                func["line_count"],
                int(func["line_coverage"]),
                func["branch_count"],
                int(func["branch_coverage"]),
                len(func["findings"]),
                func["score_cplx_locov"],
                func["score_sca_cov"],
            ]
            csvw.writerow(row)
    # end csv_fw

    # Output prioritized report
    high_risk_count = 3
    vulnerable_count = 3

    print_report("## ðŸš¨ Top High Risk Functions (Complex + Untested)\n", fw)

    count = 0
    for func in sorted(
        all_functions, key=lambda x: x["score_cplx_locov"], reverse=True
    )[:high_risk_count]:
        branch_coverage = func["branch_coverage"]
        line_coverage = func["line_coverage"]
        ccn = func["ccn"]
        if (
            line_coverage >= _min_line_coverage
            and branch_coverage >= _min_branch_coverage
        ):
            break
        if ccn < _min_complexity:
            break
        count = count + 1
        print_report(
            f"- **[`{func['name']}()`]({func['permalink']})** in `{func['file']}`", fw
        )
        print_report(f"  - Score: **{func['score_cplx_locov']}**", fw)
        print_report(
            f"  - Complexity: **{ccn}** (above threshold value: {_min_complexity})",
            fw,
        )
        branch_coverage = func["branch_coverage"]
        if branch_coverage < _min_branch_coverage:
            print_report(
                f"  - Branch Coverage: **{branch_coverage:.1f}%** (below threshold value: {_min_branch_coverage})",
                fw,
            )
        else:
            print_report(
                f"  - Branch Coverage: **{branch_coverage:.1f}%**",
                fw,
            )
        line_coverage = func["line_coverage"]
        if line_coverage < _min_line_coverage:
            print_report(
                f"  - Line Coverage: **{line_coverage:.1f}%** (below threshold value: {_min_line_coverage})",
                fw,
            )
        else:
            print_report(
                f"  - Line Coverage: **{line_coverage:.1f}%**)",
                fw,
            )
        rules_a = []
        for finding_d in func["findings"]:
            rules_a.append(finding_d["rule"])
        print_report(f"  - Critical findings: `{', '.join(rules_a)}`", fw)
        print_report("", fw)

    if count == 0:
        print_report("None detected!\n", fw)

    print_report("## ðŸ”’ Top Security Risk Functions (Prioritized by coverage)\n", fw)

    count = 0
    for func in sorted(all_functions, key=lambda x: x["score_sca_cov"], reverse=True)[
        :vulnerable_count
    ]:
        if len(func["findings"]) == 0:
            break
        count = count + 1
        print_report(
            f"- **[`{func['name']}()`]({func['permalink']})** in `{func['file']}`", fw
        )
        print_report(f"  - Score: **{func['score_sca_cov']}**", fw)
        print_report(f"  - Branch Coverage: **{func['branch_coverage']:.1f}%**", fw)
        print_report(f"  - Line Coverage: **{func['line_coverage']:.1f}%**", fw)
        rules_a = []
        for finding_d in func["findings"]:
            rules_a.append(finding_d["rule"])
        print_report(f"  - Critical findings: `{', '.join(rules_a)}`", fw)
        print_report("", fw)
    if count == 0:
        print_report("None detected!\n", fw)

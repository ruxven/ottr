#!/usr/bin/env python3

import json
import os
from collections import defaultdict
import argparse
import csv

server_url = os.getenv("GITHUB_SERVER_URL", "https://github.com")
repo = os.getenv("GITHUB_REPOSITORY", "")
sha = os.getenv("GITHUB_SHA", "")
workspace = os.getenv("GITHUB_WORKSPACE", "")

# increase these values as needed
_min_branch_coverage = 80
_min_line_coverage = 80

_min_complexity = 15

argp = argparse.ArgumentParser(description="A tool to generate a report using complexity, coverage, and sarif data")
argp.add_argument("-x","--complexity",help="Location of compltexity report generated by Lizard")
argp.add_argument("-c","--coverage",help="Location of Coverage CSV file")
argp.add_argument("-s","--sarif",help="Location of SARIF file")
argp.add_argument("-o","--output",help="Output report file to print to.")
argr = argp.parse_args()

# Load complexity data (function-level from Lizard JSON)
with open(argr.complexity, "r") as f:
    complexity_data = json.load(f)

coverage_data = []
with open(argr.coverage, "r") as f:
    coverage_data = json.load(f)

# Load Semgrep SARIF results
with open(argr.sarif) as f:
    semgrep = json.load(f)

fw = open(argr.output, "w")

def print_report(msg, fw):
    print(f"REPORT: {msg}")
    fw.write(msg + "\n")

critical_findings = defaultdict(list)
for result in semgrep["runs"][0]["results"]:
    location = result["locations"][0]["physicalLocation"]
    file_path = location["artifactLocation"]["uri"]
    rule = result["ruleId"]
    level = result.get("level", "warning")
    line_num = location.get("region", {}).get("startLine", 1)

    if level == "error":
        critical_findings[file_path].append({"rule": rule, "line": line_num})

print_report("# Developer Pain Point Report\n", fw)

high_risk_functions = []
security_risk_functions = []

def get_func_coverage(coverage_data, filename, func_name, start_line, end_line):
    branch_count = 0
    line_count = 0
    line_hit = 0
    branch_hit = 0
    
    func_d_a = []
    for file_d in coverage_data:
        filename_cmp = file_d["filename"]
        filename_cmp = filename_cmp.replace(workspace + "/", "")
        
        if filename == filename_cmp:
            func_coverage_d = file_d["function_coverage"]
            for func_d in func_coverage_d:
                line_start = func_d["line_start"]
                line_end = func_d["line_end"]

                if line_start >= start_line and line_end <= end_line:
                    func_d_a.append(func_d)

    if not func_d_a:
        print(f"WARN: Could not find {func_name} starting at {start_line}:{end_line} in {filename} in coverage data!")
    for func_d in func_d_a:
        line_count += func_d["line_count"]
        line_hit += func_d["line_hit"]
        branch_count += func_d["branch_count"]
        branch_hit += func_d["branch_hit"]
    output_t = (line_hit, line_count, branch_hit, branch_count)
    print(f"{func_name}:{output_t}")
    return output_t

# Analyze each function
for file_data in complexity_data:
    filename = file_data["filename"]

    for func in file_data.get("function_list", []):
        func_name = func["name"]
        ccn = func["cyclomatic_complexity"]
        start_line = func["start_line"]
        end_line = func["end_line"]

        # Estimate function-level coverage
        coverage_t = get_func_coverage(coverage_data, filename, func_name, start_line, end_line)
        lh, lc, bh, bc = coverage_t
        line_coverage = 0
        if lc:
            line_coverage = 100.0 * float(lh) / float(lc)
        branch_coverage = 0
        if bc:
            branch_coverage = 100.0 * float(bh) / float(bc)

        # Create permalink to specific function
        permalink = (
            f"{server_url}/{repo}/blob/{sha}/{filename}#L{start_line}-L{end_line}"
        )

        # Check for critical findings in this function's range
        func_findings = []
        for finding in critical_findings.get(filename, []):
            if start_line <= finding["line"] <= end_line:
                func_findings.append(finding["rule"])

        # High complexity + low coverage = high risk
        coverage_below_threshold = False
        if bc:
            coverage_below_threshold = branch_coverage < _min_branch_coverage
        
        if ccn >= _min_complexity and coverage_below_threshold:
            high_risk_functions.append(
                {
                    "name": func_name,
                    "file": filename,
                    "permalink": permalink,
                    "ccn": ccn,
                    "line_coverage": line_coverage,
                    "branch_coverage": branch_coverage,
                    "findings": func_findings,
                }
            )

        # Has coverage but critical security findings
        elif func_findings and line_coverage > 0:
            security_risk_functions.append(
                {
                    "name": func_name,
                    "file": filename,
                    "permalink": permalink,
                    "line_coverage": func_line_coverage,
                    "branch_coverage": func_branch_coverage,
                    "findings": func_findings,
                }
            )

# Output prioritized report
print_report("## ðŸš¨ High Risk Functions (Complex + Untested)\n", fw)
if high_risk_functions:
    for func in sorted(high_risk_functions, key=lambda x: x["ccn"], reverse=True):
        print_report(f"- **[`{func['name']}()`]({func['permalink']})** in `{func['file']}`", fw)
        print_report(f"  - Complexity: **{func['ccn']}** (above threshold value: {_min_complexity})", fw)
        print_report(f"  - Branch Coverage: **{func['branch_coverage']:.1f}%** (below threshold value: {_min_branch_coverage})", fw)
        if func["findings"]:
            print_report(f"  - Critical findings: `{', '.join(func['findings'])}`", fw)
        print_report("", fw)
else:
    print_report("None detected!\n", fw)

print_report("## ðŸ”’ Security Risk Functions (Tested but Vulnerable)\n", fw)
if security_risk_functions:    
    for func in security_risk_functions:
        print_report(f"- **[`{func['name']}()`]({func['permalink']})** in `{func['file']}`", fw)
        print_report(f"  - Branch Coverage: **{func['branch_coverage']:.1f}%**", fw)
        print_report(f"  - Critical findings: `{', '.join(func['findings'])}`", fw)
        print_report("", fw)
else:
    print_report("None detected!\n", fw)